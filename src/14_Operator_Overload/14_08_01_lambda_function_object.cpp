#include <iostream>
#include <string>
#include <algorithm>
#include <vector>

using namespace std;

// a lambdag generate a class like this:
class ShorterString {
public:
    ShorterString() {cout << "ShorterString class: constructor" << endl;}
    bool operator()(const string &s1, const string &s2){
        cout << "ShorterString class: operator()" << endl;
        return  s1.size() < s2.size();
    }
};

class CaptureWithValue{
public:
    CaptureWithValue(size_t s):sz(s) { cout << "CaptureWithValue class: constructor, size is: " << sz << endl; }
    bool operator()(const string &s)
    {
        cout << "CaptureWithValue class: operator()" << endl;
        return s.size() > sz;
    }
private:
    size_t sz;
};

int main()
{
    // lambda creates a unnamed class's unnamed object
    // and the class generated by the lambda has a overloaded operator()
    // just like we wrote in previous chapter

    vector<string> words {"hi", "hello", "c++", "primer"};
    stable_sort(words.begin(), words.end(), [](const string &a, const string &b){ return a.size() < b.size(); });
    for_each(words.begin(), words.end(), [](string s){ cout << s << " "; });    // "hi c++ hello primer ""

    // use object
    stable_sort(words.begin(), words.end(), ShorterString());
    for_each(words.begin(), words.end(), [](string s){ cout << s << " "; });
    // result is:
    // hi c++ hello primer ShorterString class: constructor
    // ShorterString class: operator() 
    // ShorterString class: operator()
    // ShorterString class: operator()
    // ShorterString class: operator()
    // ShorterString class: operator()
    // ShorterString class: operator()
    // hi c++ hello primer

    // captures
    // if captures reference, then the unnamed class just pass the reference
    // but if captures a value, then the class will have a data member to store that value
    size_t sz = 3;
    auto wc = find_if(words.begin(), words.end(), CaptureWithValue(sz));
    cout << "find with object: " << *wc << endl;

    wc = find_if(words.begin(), words.end(), [sz](const string &s){
        cout << "find with lambda function" << endl;
        return s.size() > sz;
    });
    cout << "find with lambda: " << *wc << endl;

    return 0;
}